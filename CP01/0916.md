# 第一讲-数据结构

教材： FD + TS 版

存储， 传递， 转换；

面向对象 cpp

## 要求

概念 + 使用方法  + 实现;

**简单的**算法分析(时间/空间);

上机 + pj

成绩: 50期末 + 15期中(闭卷 11月下旬) + 35(pj + 上机 + 作业)

### CP01

- 数据结构的概念

- 抽象形式ADT(cpp classes)

- 算法(定义)

- 性能分析

### 1.1 数据结构的概念

数据 = 信息载体, 存储组织的方式 &emsp; 数值`unsigned, int`/非数值`char, string` <- 数据项

![0](https://latex.codecogs.com/svg.latex?%5Cint_a%5Ebf(x)%5C)

![1](https://latex.codecogs.com/svg.latex?{DS}=\lbrace{D},{R}\rbrace\)

网络连通: Tree树状(min_cost) / Graph网状

数据的**逻辑**结构：与存储无关， 逻辑关系；

- 线性结构： 线性表
`1 -- > 2 -- > 3 --> N`

- 非线性结构：树，图

存储结构：依赖于实现

- 顺序存储/链接存储(内存)

- 索引存储/散列存储(外部存储)

### 1.2.1 数据类型

- 一组属性相同的值的集合 基本 + 构造

### 1.2.2 抽象数据类型ADT

- 由基本的数据类型组成, 包括一组操作

- 信息屏蔽, 封装; 使用实现接口分离

- 类，对象，实例

- 模板 实现软件复用

- 函数 + 类模板

类模板：

```C++
template<typename T>
class dataList{
    T* element;
    int arr_size;
    ...
}
...
    dataList<T> test;
```

### 1.4 算法

- 一个有穷的指令集

- 输入 Input (0, ∞)

- 输出 Output 一个/多个

- 确定性: 每一步定义是确切的

- 有穷性: 有限步后算法结束

- 有效性: 每一条运算足够基本

**算法**: 有穷性, 面向问题;

**程序**: 可能持续进行, 具体语言实现;

### 1.5 算法性能分析与度量

`time()` 计时 **精度**问题

固定空间(静态空间) + 动态空间

时间复杂度：

- 编译时间: 与编译程序相关

- 运行时间: 程序步数: 声明语句 = 0, 表达式 = 1

- 程序步数的计算 列表/估算(count全局变量, 只能较为简单的估计)

- 大O表示法 $O(N)$

**最坏情况**: 当且仅当存在正整数c和n0, 使得![2](http://latex.codecogs.com/svg.latex?T(n)<=cf(n)),![3](http://latex.codecogs.com/svg.latex?n>= n_0);
&emsp; &emsp; O(f(n)) = 算法存在的一个增长上界

- 考虑关键操作的程序步数

- 单循环: 关键路径为循环内的简单语句

- 并行循环 加法规则

- 嵌套循环 由最内层的循环语句决定 乘法规则

![4](http://latex.codecogs.com/svg.latex?T(n, m) = T1(n) + T2(m) = O(max(f(n), g(m))))

- 渐进的空间复杂度

### 1.5.1

代价计算方法的比较: 事前估计!

1. (从最坏的数据情况进行估计) && 事后测试(具体的数据与场景)  

2. 通常: 两者进行结合
